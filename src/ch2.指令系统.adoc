== 指令系统

=== 汇编语言及其操作数

汇编语言是一种介于机器语言和高级语言之间的低级编程语言，它以符号化的助记符代替机器语言中的二进制操作码和内存地址，帮助程序员更容易地与硬件交互。汇编语言的作用主要体现在直接控制硬件、优化程序性能和深入理解计算机系统等方面。在操作系统开发、驱动程序编写和嵌入式系统设计中，汇编语言因其对硬件资源的精确控制而被广泛应用。此外，汇编语言还常用于程序性能优化，通过手动调整指令和资源分配，可以实现更高效的代码执行。

汇编语言具有与硬件高度相关、符号化表示低级操作、高效率但复杂性高等特点。由于其紧密依赖于特定的处理器架构，每种汇编语言的指令集和功能都与相应的硬件设计息息相关，导致它在不同平台之间无法直接移植。相比于高级语言，汇编语言的可读性和可维护性较差，但在运行效率上更具优势。其符号化的表示方式虽然简化了机器语言的复杂性，但仍需要程序员对底层硬件有深入的理解和掌控。

汇编语言与高级语言处于不同的抽象层次，两者既有显著区别又具有密切联系。高级语言通过抽象屏蔽底层硬件细节，使程序设计更接近自然语言，极大地提高了开发效率和可移植性。然而，高级语言编写的程序需要经过编译器翻译成汇编代码，最终再由汇编器转为机器码，这使得高级语言程序的执行效率通常不如汇编语言。在实际开发中，高级语言和汇编语言往往结合使用。当程序对性能和硬件操作有极高要求时，开发者可以选择用汇编语言编写关键模块，将其嵌入到高级语言中，以兼顾系统性能与开发效率。汇编语言在优化代码性能和深入理解系统底层运作方面仍具有不可替代的价值，与高级语言共同构成了完整的编程工具体系。

汇编语言的操作数种类多样，通常包括立即数、寄存器和内存地址三种形式。立即数是直接嵌入指令中的具体值，表示常量数据，使用时无需额外的存储访问，因此处理速度快但灵活性较低。寄存器操作数指存储在处理器内部寄存器中的数据，由于寄存器是处理器中访问速度最快的存储单元，寄存器操作数的使用能够显著提高运算效率。然而，由于寄存器数量有限，寄存器操作数的应用通常需要精心规划和优化。内存地址操作数则指向存储在主存中的数据，虽然存储空间更大，但访问内存操作数需要额外的存储访问时间，可能影响指令执行的速度。

汇编语言的操作数具有低级性和直接性的特点，完全依赖于底层硬件的体系结构。每种处理器架构定义了支持的操作数类型、数量以及操作数的位置规则。例如，一些架构允许指令同时包含多个操作数，而另一些架构则限制为单一操作数或特定的寻址模式。这种对硬件特性的依赖使得汇编语言的操作数灵活性受到一定限制，同时导致其代码在不同硬件平台之间的可移植性较差。

操作数的寻址方式是汇编语言的另一个显著特点。处理器支持多种寻址模式，用于确定操作数的具体位置，包括直接寻址、间接寻址、寄存器寻址、偏移寻址等。不同的寻址方式为程序提供了多样化的操作数访问手段，使开发者可以根据具体需求优化代码性能和存储使用。例如，在循环操作中，偏移寻址可以简化数组元素的访问，而寄存器寻址则能最大限度地提高运算效率。

==== 存储器操作数

处理器只能在寄存器中保存少量数据，但是计算机内存可以存储数十亿数据元素。因此数据结构（数组和结构体）可以保存在内存中。由于RISC-V指令中的算术运算只作用于寄存器，因此，RISC-V必须包含在内存和寄存器之间传输数据的指令。这些指令称为数据传输指令。要访问内存中的字，指令必须提供内存地址。内存只是一个大型一维数组，其地址作为该数组的下标，从0开始。将数据从内存复制到寄存器的数据传输指令通常称为载入指令（load）。载入指令的格式是操作名称后面紧跟数据待取的寄存器，然后是寄存器和用于访问内存的常量。指令的常量部分和第二个寄存器中的内容相加组成内存地址。实际的RISC-V指令名称是lw，表示取字。

加载字和存储字是在RISC-V体系结构中存储器和寄存器之间传输字的指令。许多程序有着比计算机中寄存器数量更多的变量。所以，编译器会尽量把最常用的变量存放在寄存器中，剩下的存放在内存中，使用load和store在寄存器和内存之间传输变量。将不常用的变量（或稍后才使用的变量）存放到内存的过程称为寄存器换出。关于大小和速度的硬件设计原则表明内存一定比寄存器慢，因为寄存器更少。事实确实如此，如果数据在寄存器而不是内存中，数据访问速度会更快。而且，数据在寄存器中更有用。RISC-V算术指令可以读取两个寄存器，对它们进行操作并写入结果。RISC-V数据传输指令只读取一个操作数或写入一个操作数，并不对其进行操作。因此，与内存相比，寄存器的访问时间更短，吞吐率更高。这使得寄存器中的数据访问速度更快，使用更简单。与访问内存相比，访问寄存器所需的能耗也少得多。要获得最高的性能并节约能耗，指令系统体系结构必须有足够多的寄存器，并且编译器必须有效使用寄存器。

==== 常数或立即数操作数

通过把常数作为算术指令操作数，和从存储器中取出常数相比，操作速度更快，能耗更低。

常数0有另一个作用，通过有效使用它可以简化指令系统体系结构。例如可以使用常数0寄存器求原数的相反数。因此，RISC-V专用寄存器x0硬连线到常数0.根据使用频率来确定要定义的常数，这是第一章中重要思想加速经常性事件的实例。

==== 有符号数与无符号数

在计算机内部，有符号数（正负数）和无符号数的表示依赖于二进制编码方式。计算机使用固定长度的二进制位来表示数据，如何区分正数、负数或单纯的无符号数取决于所选的编码规则。

有符号数需要区分正数和负数，因此通常使用最高位（即最左侧的位）作为符号位，剩余的位表示数值。符号位为0表示正数，为1表示负数。以下是常用的有符号数表示方法：

- 原码

	原码是一种直接的表示方式，符号位加上数值的绝对值。例如，8位二进制中，+5表示为00000101，-5表示为10000101。虽然原码表示简单，但在进行运算时，符号位需要单独处理，运算逻辑较为复杂，因此不常用于计算机实际运算。

- 反码

	反码的符号位与原码相同，但负数的数值部分通过对原码取反（0变1，1变0）得到。例如，+5的反码是00000101，而-5的反码是11111010。反码在加减运算中简化了一部分逻辑，但依然存在问题，如表示零时会有+0和-0两种形式。

- 补码

	补码是计算机中最常用的有符号数表示方法。正数的补码与其原码相同，而负数的补码通过对原码取反后加1得到。例如，+5的补码为00000101，而-5的补码为11111011。补码的优点是可以将减法统一为加法运算，且解决了零的双重表示问题（补码中只有一种形式的零）。由于这些特性，补码成为现代计算机处理有符号数的标准。

无符号数的表示

无符号数只表示非负整数，因此所有二进制位都用于表示数值，不包含符号位。例如，在8位二进制中，00000000表示0，11111111表示255。无符号数的范围为stem:[(0, 2^n - 1)],其中stem:[n]是二进制位数。

=== 计算机中的指令表示

TIP: 图

RISC-V 的指令根据功能不同分为多种格式，例如 R 型、I 型、S 型、B 型、U 型和 J 型。这些格式共享某些字段，但也有独特部分。32 位指令的通用结构包括以下字段：

Opcode（操作码，7 位）

	位置：第 0-6 位（从右向左编号，最右侧为第 0 位）。
	含义：指定指令的基本操作类型，如算术运算、内存访问、控制流指令等。
	作用：操作码决定指令的功能类别，结合其他字段进一步解析具体操作。


rd（目标寄存器，5 位）

	位置：第 7-11 位。
	含义：指定操作结果的目标寄存器编号（0-31，对应 32 个寄存器）。
	作用：表示操作结果将存储到的寄存器。

funct3（功能码，3 位）

	位置：第 12-14 位。
	含义：提供次级操作分类，与操作码配合，用于进一步区分指令功能，例如加法与减法。
	作用：在同一操作码下区分具体操作类型。

rs1（源寄存器 1，5 位）

	位置：第 15-19 位。
	含义：指定第一个源操作数的寄存器编号。
	作用：表示操作中需要读取的第一个操作数。

rs2（源寄存器 2，5 位）

	位置：第 20-24 位。
	含义：指定第二个源操作数的寄存器编号。
	作用：表示操作中需要读取的第二个操作数（仅适用于部分指令类型，如 R 型指令）。

funct7（功能码扩展，7 位）

	位置：第 25-31 位。
	含义：提供进一步的操作区分信息，与 funct3 和操作码结合，确定特定指令行为（如区分加法和减法）。
	作用：用于增强功能分类，扩展指令集。

立即数字段（不同格式中的位置和长度可变）

	含义：表示常量值，用于偏移量、地址或立即操作数等用途。
	作用：立即数在不同指令格式中位置不同，但均用于表示直接参与操作的固定值。

TIP: 可以接着补充不同类型指令的格式

=== 逻辑操作指令

[cols="1,1,1,1", options="header"]
|===
| 逻辑操作类型 | C操作符 |Java操作符 | 对应的RISC-V指令

| 左移 (Shift Left)
| <<
|<<
| SLL 指令：`sll rd, rs1, rs2` 或 `slli rd, rs1, imm`

| 逻辑右移 (Shift Right Logical)
| >>
| >>>
| SRL 指令：`srl rd, rs1, rs2` 或 `srli rd, rs1, imm`

| 算术右移 (Shift Right Arithmetic)
| >>
| >>
| SRA 指令：`sra rd, rs1, rs2` 或 `srai rd, rs1, imm`

| 按位与 (Bitwise AND)
| &
| &
| AND 指令：`and rd, rs1, rs2`

| 按位或 (Bitwise OR)
| \|
| \|
| OR 指令：`or rd, rs1, rs2`

| 按位异或 (Bitwise XOR)
| ^
| ^
| XOR 指令：`xor rd, rs1, rs2`

| 按位非 (Bitwise NOT)
| ~
| ~
| 取反指令：`xori rd, rs1, -1`


|===

=== 决策指令

使用条件分支指令（beq、bne等）进行回跳（循环）或前跳（if）。

[cols="1,1,1", options="header"]
|===
| 指令 | 含义 | 功能描述

| `beq rs1, rs2, offset`
| Branch if Equal
| 如果`rs1`等于`rs2`，跳转到`PC + offset`指定的地址

| `bne rs1, rs2, offset`
| Branch if Not Equal
| 如果`rs1`不等于`rs2`，跳转到`PC + offset`指定的地址

| `blt rs1, rs2, offset`
| Branch if Less Than (Signed)
| 如果`rs1`小于`rs2`（有符号比较），跳转到`PC + offset`指定的地址

| `bge rs1, rs2, offset`
| Branch if Greater Than or Equal (Signed)
| 如果`rs1`大于或等于`rs2`（有符号比较），跳转到`PC + offset`指定的地址

| `bltu rs1, rs2, offset`
| Branch if Less Than (Unsigned)
| 如果`rs1`小于`rs2`（无符号比较），跳转到`PC + offset`指定的地址

| `bgeu rs1, rs2, offset`
| Branch if Greater Than or Equal (Unsigned)
| 如果`rs1`大于或等于`rs2`（无符号比较），跳转到`PC + offset`指定的地址

| `jal rd, offset`
| Jump and Link
| 跳转到`PC + offset`指定的地址，并将返回地址（`PC + 4`）保存到寄存器`rd`

| `jalr rd, rs1, offset`
| Jump and Link Register
| 跳转到寄存器`rs1 + offset`的地址，并将返回地址（`PC + 4`）保存到寄存器`rd`
|===

虽然常量通常很短并且适合12位字段，但有时它们也会更大。

RISC-V指令系统包括指令load upper immediate(取立即数高位，lui)，用于将20位常数加载到寄存器的第31位到第12位。最右边的12位全部用0填充。例如，这条指令允许使用两条指令创建32位常量。lui使用新的指令格式——U型，因为其他格式不能支持如此大的常量。

TIP: 补充例子p82

==== RISC-V寻址模式总结

[cols="1,1,1", options="header"]
|===
| 寻址模式 | 定义 | 应用与特点

| 立即数寻址
| 操作数直接嵌入指令中，作为常量值。
| 常用于加法、减法等运算，或加载、存储指令中的常量。
  示例：`addi rd, rs1, imm`，将`rs1`与立即数`imm`相加，并存储到`rd`寄存器。

| 寄存器寻址
| 操作数位于寄存器中，指令通过寄存器指定操作数的位置。
| 常用于寄存器之间的数据传输与算术运算。非常快速。
  示例：`add rd, rs1, rs2`，将`rs1`与`rs2`相加并将结果存储在`rd`中。

| 基址寻址
| 操作数地址通过基地址寄存器和立即数偏移量计算得出。
| 常用于内存访问，基址寄存器用于存储数据结构起始地址，偏移量指定数据位置。
  示例：`lw rd, offset(rs1)`，将内存地址`rs1 + offset`处的数据加载到`rd`。

| PC相对寻址
| 操作数的地址是相对于当前PC值的偏移量计算得出。
| 用于条件跳转与程序控制，确保程序在不同内存位置加载时的正确性。
  示例：`beq rs1, rs2, offset`，若`rs1`和`rs2`相等，跳转到`PC + offset`。
  示例：`jal rd, offset`，跳转到`PC + offset`并保存返回地址到`rd`寄存器。
|===

TIP: 附图p85

==== 条件分支指令

[source,asm]
----
# 如果rs1中的值与rs2中的值相等，那么PC跳转到标签L1处
beq rs1, rs2, L1

# 如果rs1中的值与rs2中的值不相等，那么PC跳转到标签了L2处
bne rs1, rs2, L2
----

==== 循环

[source,asm]
----
# rs1持续加一，直到rs1等于10则退出循环
addi rs1, rs0, 1
addi rs2, rsr0, 10
Loop:
addi rs1, rs1 ,1
beq rs1, rs2, Exit
j Loop
Exit:
# 退出循环
----

TIP: 更改为公式块

对相等或不相等的判断可能是最常见的判断，但也有很多其他两个数之间的关系。例如，for循环可能需要判断下标变量是否小于0。完整的相互关系有小于（<）、小于等于（≤）、大于（>）、大于等于（≥）、相等（=）、不等于（≠）。

位模式的比较还必须处理有符号和无符号数之间的差别。有时候，最高有效位是1代表一个负数，当然，它小于任何正数（最高有效位是0）。另一方面，对于无符号整数，最高有效位是1表示大于任何最高有效位是0的数。（我们很快将利用最高有效位的这种双重含义来降低数组边界检查的成本。）RISC-V提供了指令来处理这两种情况。这些指令与beq和bne具有相同的形式，但是执行不同的比较。小于则分支指令（b1t）比较寄存器rsl和rs2中的值（采用二进制补码表示），如果rsl中的值较小则跳转。大于等于分支（bge）指令是相反情况，也就是说，如果rsl中的值至少不小于rs2中的值则跳转。无符号的小于则分支指令（b1tu）意味着，如果二者是无符号数，那么rsl中的值小于rs2中的值则跳转。最后，无符号数的大于等于则分支指令（bgeu)在相反的情况下跳转。

另一种提供这些额外分支指令的方法是根据比较结果设置寄存器，然后使用beq或bne指令根据该临时寄存器中的值来进行分支判断。这种由MIPS指令系统使用的方法可以使处理器数据通路稍微简单一些，但它需要更多指令来表达程序。

ARM指令系统使用的另一种方法是，保留额外的位来记录指令执行期间发生的情况。这些额外的位称为条件代码或标志位，用于表明例如算术运算的结果是否为负数或零，或溢出。条件分支利用这些条件代码的组合来执行期望的判断。条件代码的一个缺点是，如果许多指令总是设置它们，则会生成让流水线执行困难的依赖关系（参见第4章）。

- 边界检查的简便方法

	将有符号数当作无符号数处理，给我们提供了一种低成本的方式检查是否0≤x<y，常用于检测数组下标是否越界。关键在于二进制补码表示中的负整数看起来像无符号表示中很大的数；因为最高有效位在有符号数中表示符号位，但在无符号数中表示数的很大一部分。因此，无符号比较x<y在检测x是否小于y的同时，也检测了x是否为负数。

==== case/switch语句

两种方法：

1. 将case/switch语句转换为if-then-else语句

2.  使用分支地址表。程序索引到地址表中，然后跳转到对应的地址。

	编码形成指令序列的地址表，称为分支地址表或分支表，程序只需要索引到表中，然后跳转到合适的指令序列。因此，分支表只是一个字数组，其中包含与代码中的标签对应的地址，该程序将分支表中的相应条目加载到寄存器中。然后需要使用寄存器中的地址进行跳转。为了支持这种情况，RISC-V这类指令系统包含一个间接跳转指令，该指令对寄存器中指定的地址执行无条件跳转。在RISC-V中，跳转-链接指令（jalr）用于此目的。

	分支地址表：也称作分支表，一种包含了不同指令序到地经的表。

=== 计算机硬件对函数的支持

过程(procedure)或函数是编程人员用于结构化编程的一种工具，两者均有助于提高程序的可理解性和代码的可重用性。过程允许程序员一次只专注于任务的一部分；参数可以传递数值并返回结果，因此用以充当过程和其余程序与数据之间的接口。

过程是用软件实现抽象的一种方式。可以把过程想象成一个携带秘密计划离开的侦探，他获取资源，执行任务，掩盖踪迹，然后带着预期结果返回原点。一旦任务完成，则再无任何干扰。更重要的是，侦探只在“需要知道”的基础上运作，因此侦探不能对雇主同样，在执行过程时，程序必须遵循以下六个步骤：

1. 将参数放在过程可以访问的位置
2. 将控制转交给过程（函数）
3. 获得过程所需的储存资源
4. 执行任务
5. 将结果放在调用程序可以访问的位置
6. 将控制返回初始点

过程:

	一个根据给定参教执行特定任务的已存储的子程序。

跳转一链接指令:

	政转到某个地址的同时得下一条指今的地址保存在寄存器（在RISC-V中还常是x1）中的指令。

==== 使用更多的寄存器

假设对于一个过程，编译器需要比8个参数寄存器更多的寄存器。由于在任务完成后必须掩盖踪迹，调用者所需的所有寄存器都必须恢复到调用该过程之前所存储的值。换出寄存器的理想数据结构是栈（stack）——一种后进先出的队列。栈需要一个指向栈中最新分配地址的指针，以指示下一个过程应该放置换出寄存器的位置或寄存器旧值的存放位置。在RISC-V中，栈指针(stack pointer)是寄存器x2.也称为sp。栈指针按照每个被保存或恢复的寄存器按字进行调整。栈应用非常广泛，因而传送数据到栈或从栈传输数据都具有专业术语：将数据放人栈中称为压栈，从栈中移除数据称为弹栈。

按照历史惯例，栈按照从高到低的地址顺序“增长”。这就意味着可以通过减栈指针将值压栈；通过增加栈指针缩小栈，从而弹出栈中的值。

在运行过程（函数）时，在栈中存储局部变量，在堆中存储常量和静态变量


栈:
	
	一种被组织成后进先出队列并用于寄存器换出的数据结构。

栈指针：

	指示栈中最新分配的地址的值，用于指示应该被换出的寄存器的位置，或寄存艺旧值的存放位置。在RISC-V中为齐存器sp或x2。

压栈：

	向栈中添加元素。
	
弹楼：

	从栈中移除无素。

==== 嵌套过程

不调用其他过程的过程称为叶子（leaf）过程。如果所有过程都是叶子过程，情况将会变得简单，但事实并非如此。正如一个侦探任务的一部分可能是雇佣其他侦探一样，被雇佣的侦探进而雇佣更多的侦探，过程调用其他过程也是如此。更进一步，递归过程甚至调用的是自身的“克隆”。就像在过程中使用寄存器时需要小心一样，在调用非叶子过程时必须更加注意。

一种解决方法是将其他所有必须保存的寄存器压栈，就像保存寄存器压栈一样。调用者将所有调用后还需要的参数寄存器(x10-x17）或临时寄存器(x5-×7和×28-×31)压栈。被调用者将返回地址寄存器x1和被调用者使用的保存寄存器(x8~x9和x18~x27)压栈。调整栈指针sp以计算压栈寄存器的数量。返回时，从存储器中恢复寄存器并重新调整栈指针。

==== 在栈中为新数据分配空间

TIP: 详细附图说明或删除

==== 在堆中为新数据分配空间

TIP: 详细附图说明或删除

=== 并行性与指令：同步

当任务之间相互独立时，并行执行更为容易，但通常任务之间需要协作。协作通常意味着一些任务正在写人其他任务必须读取的值。需要知道任务何时完成写人以便其他任务安全地读出，因此任务之间需要同步。如果它们不同步，则存在数据竞争（data race)的危险，那么程序的结果会根据事件发生的次序而改变。

在计算中，同步机制通常由用户级的软件例程所构建，而这依赖于硬件提供的同步指令。加锁和解锁可直接用于创建只有单个处理器可以操作的区域，称为互斥(mutual exclusion)区，以及实现更复杂的同步机制。

在多处理器中实现同步所需的关键是一组硬件原语，能够提供以原子方式读取和修改内存单元的能力。也就是说，在内存单元的读取和写入之间不能插人其他任何操作。如果没有这样的能力，构建基本同步原语的成本将会很高，并会随着处理器数量的增加而急剧增加。

有许多基本硬件原语的实现方案，所有这些都提供了原子读和原子写的能力，以及一些判断读写是不是原子操作的方法。通常，体系结构设计人员不希望用户使用基本的硬件原语，而是期望系统程序员使用原语来构建同步库，这个过程通常复杂且棘手。

原子交换(atomic exchange或atomic swap)原语是构建同步机制的一种典型操作，会将寄存器中的值与存储器中的值进行交换。为了了解如何使用它来构建基本同步原语，假设要构建一个简单的锁变量，其中值0用于表示锁变量可用，值1用于表示锁变量已被占用。处理器尝试通过将寄存器中的1与该锁变量对应的内存地址的值进行交换来设置加锁。如果某个其他处理器已声明访问该锁变量则交换指令的返回值为1，表明该锁已被其他处理器占用，否则为0，表示加锁成功。在后一种情况下，锁变量的值变为1，以防止其他处理器也加锁成功。

例如，考虑两个处理器尝试同时进行交换操作：这种竞争会被阻止，因为其中一个处理器将首先执行交换，并返回0，而第二个处理器在进行交换时将返回1。使用交换原语实现同步的关键是操作的原子性：交换是不可分割的，硬件将对两个同时发生的交换进行排序。尝试以这种方式设置同步变量的两个处理器都不可能认为它们同时设置了变量。

实现单个的原子存储操作为处理器的设计带来了一些挑战，因为它要求在单条不可中断的指令中完成存储器的读和写操作。

另一种方法是使用指令对，其中第二条指令返回一个值，该值表示该指令对是否被原子执行。如果任何处理器执行的所有其他操作都发生在该对指令之前或之后，则该指令对实际上是原子的。因此，当指令对实际上是原子操作时，没有其他处理器可以在指令对之间改变值。在RISC-V中，这对指令指的是一个称为保留加载（load-reserved）字（1r.w)的特殊加载指令和一个称为条件存储(store-conditional）字(sc.w）的特殊存储指令。这些指令按序使用：如果保留加载指令指定的内存位置的内容在条件存储指令执行到同一地址之前发生了变化，则条件存储指令失败且不会将值写入内存。条件存储指令定义为将（可能是不同的）寄存器的值存储在内存中，如果成功则将另一个寄存器的值更改为0.如果失败则更改为非零值。因此，SC.w指定了三个寄存器：一个用于保存地址，一个用于指示原子操作失败或成功，还有一个用于如果成功则将值存储在内存中。

=== 翻译并启动程序

[cols="1,1", options="header"]
|===
| 工具 | 作用

| 编译器 (Compiler)
| 将高级语言（如C、C++）源代码转换成中间代码或机器代码。编译器负责语法分析、语义分析、优化和目标代码生成。它生成一个独立的可执行文件，通常为机器语言指令，供计算机直接执行。

| 汇编器 (Assembler)
| 将汇编语言代码转换成机器代码或目标代码。汇编器负责将汇编语言的每条指令映射为相应的机器指令。它处理符号（如标签和变量）并生成对应的机器代码文件（通常是`.obj`文件）。

| 链接器 (Linker)
| 将多个目标文件（通常是由编译器或汇编器生成的）和库文件结合在一起，生成一个可执行文件。链接器负责解决符号引用、地址分配和代码重定向，使程序中的函数和变量能够正确地互相引用。

| 加载器 (Loader)
| 将可执行文件加载到内存中并准备执行。加载器将程序的各个部分（如代码段、数据段）载入内存，并将控制权交给操作系统或程序的入口点，开始执行程序。它还可能进行地址重定位，确保程序在内存中正确运行。
|===


编译器、汇编器、链接器和加载器是计算机程序开发过程中密切协作的四个关键工具，它们分别承担不同的角色，并且在程序生成和执行过程中依赖彼此的工作。编译器是程序开发的第一步，它将高级语言（如C语言）源代码转换为汇编语言或中间代码。汇编器接下来会将编译器生成的汇编代码转换为机器代码或目标代码，产生可供计算机理解的低级语言。生成的目标代码通常是一个或多个独立的文件，但这些文件还不能直接执行，因为它们可能包含未解析的符号或地址引用。链接器接管这个任务，它将多个目标文件和库文件合并成一个完整的可执行文件，并解决其中的符号引用，调整内存地址，确保所有函数和数据能够正确链接和引用。

当程序准备好并生成了可执行文件之后，加载器的工作就开始了。加载器负责将可执行文件加载到内存中，并将程序控制权交给操作系统或程序的入口点，从而启动程序的执行。在加载过程中，加载器可能还会进行地址重定位，确保程序能够在内存的不同位置运行。总的来说，编译器、汇编器、链接器和加载器共同协作，将开发者编写的高级程序转化为最终可在计算机上运行的可执行文件，并确保程序的各个部分能够正确连接和执行。

TIP:附图p90

==== 动态链接库

TIP: 对照书内容p94

动态链接库（Dynamic Link Library，简称DLL）是一种在程序运行时动态加载和链接的库文件。与静态链接库不同，动态链接库在程序编译时并不直接包含进可执行文件，而是在程序运行时根据需要加载到内存中。DLL文件通常包含一组函数、数据或资源，供其他程序或模块在执行过程中调用。这种方式能够实现模块化的编程，多个程序可以共享同一个DLL文件，从而减少内存和磁盘空间的占用。

动态链接库的主要作用是提供程序功能的共享和扩展。通过将常用的功能封装在DLL中，开发者可以避免重复编写相同的代码，并且在程序运行时可以灵活地加载和调用这些功能。当多个程序需要相同的功能时，它们可以共享同一个DLL，避免每个程序都包含一份相同的代码，这样不仅节省了资源，还使得程序的更新和维护变得更加简便。通过更新DLL文件中的代码，所有使用该库的程序都能够自动获得更新，而无需重新编译和发布每个程序。

此外，动态链接库还提供了运行时的灵活性。程序可以根据需求加载和卸载DLL，使得系统能够更有效地管理内存。它还支持程序的插件式架构，允许在不修改主程序的情况下添加新的功能或模块，从而提升了程序的可扩展性和维护性。

<<<