== 处理器

=== 单周期处理器实现


实现一个单周期处理器需要多个关键模块协同工作，以便在一个时钟周期内完成指令的取指、译码、执行、存储访问和写回操作。这些模块包括控制单元、寄存器文件、算术逻辑单元（ALU）、程序计数器（PC）、指令存储器、数据存储器以及各种多路选择器（MUX）和信号通路（Bus）。

- 程序计数器（PC）

	程序计数器存储当前指令的地址，并在每个时钟周期自动更新以指向下一条指令。PC的输出作为指令存储器的输入地址。对于跳转或分支指令，PC的值可能由控制单元计算并更新。

- 指令存储器

	指令存储器根据 PC 提供的地址，输出当前指令的二进制码。指令由操作码（opcode）、寄存器地址（源寄存器、目标寄存器）和立即数等字段组成，这些字段作为后续模块的输入。

- 控制单元

	控制单元负责解析指令的操作码，生成控制信号以指导其他模块的行为。例如：
	决定 ALU 执行的操作（加、减、逻辑运算等）。
	控制数据存储器的读写行为。
	控制寄存器文件的数据读写方向。
	选择跳转或分支地址。
	控制单元的输出信号连接到 ALU、数据存储器、多路选择器和其他模块。

- 寄存器模块

	寄存器模块存储处理器的操作数。它包含多个通用寄存器：
	根据指令的源寄存器字段，从寄存器文件中读取操作数。
	根据目标寄存器字段，将计算结果写回寄存器文件。
	寄存器文件的读写操作由控制单元生成的控制信号控制。

- 算术逻辑单元（ALU）

	ALU 执行算术和逻辑运算，例如加法、减法、位与、位或等。它的输入操作数来自寄存器模块或立即数，具体取决于指令类型（R 型、I 型等）。ALU 的输出即为运算结果，通常存储回寄存器文件或用于分支条件的判断。

- 数据存储器

	数据存储器用于加载或存储数据，支持内存读写操作：
	加载指令（如 lw）从数据存储器读取数据，并将其送入寄存器文件。
	存储指令（如 sw）将寄存器文件中的数据写入数据存储器。
	数据存储器的地址和数据由指令字段和 ALU 的运算结果决定，其读写行为由控制信号控制。

- 多路选择器（MUX）

	多路选择器用于在多种可能的输入中选择一个作为输出。主要用途包括：
	在立即数和寄存器操作数之间选择 ALU 输入。
	在 ALU 输出和数据存储器输出之间选择寄存器写入的数据。
	在顺序地址和跳转目标地址之间选择 PC 的下一个值。

- 信号通路和总线

	信号通路用于连接各个模块，允许数据和控制信号在模块之间流动。总线是一种共享的通信通道，可用于传递指令、数据或地址。

TIP: p176

通过这些模块的紧密配合，单周期处理器能够在一个时钟周期内完成一条指令的全部执行过程。虽然结构简单，但由于所有操作都必须在单个周期内完成，其性能受限于最慢路径的延迟。

==== 逻辑设计的基本方法

RISC-V实现中的数据通路包含两种不同类型的逻辑单元：处理数据值的单元和存储状态的单元。处理数据值的单元是组合逻辑，它们的输出仅依赖于当前输人。给定相同的输人，组合逻辑单元总是产生相同的输出。例如，ALU就是一个组合逻辑单元。由于组合逻辑单元没有内部存储功能，当给定一组输人时，它总是产生相同的输出。

设计中的其他单元不是组合逻辑，而是包含状态的。如果一个单元有内部存储功能，它就包含状态，称其为状态单元。这是因为关机后重启计算机，通过恢复状态单元的原值，计算机可继续运行，就像没有发生过断电一样。进一步地，这些状态单元可以完整地表征计算机。例如，指令存储器、数据存储器以及寄存器都是状态单元。

一个状态单元至少有两个输人和一个输出。必需的输入是要写入状态单元的数据值和决定何时写入数据值的时钟信号。状态单元的输出提供了在前一个时钟周期写入单元的数据值。例如，逻辑上最简单的一种状态单元是D触发器，它有两个输入(一个数据值和一个时钟）和一个输出。除了触发器，RISC-V的实现中还用到了另外两种状态单元：存储器和寄存器。状态单元何时被写入由时钟确定，但是它随时可以被读。

包含状态的逻辑部件也被称为时序的，因为其输出取决于输人和内部状态。例如，表示寄存器的功能单元的输出取决于所提供的寄存器号和之前写人寄存器的内容。

**时钟同步方法**

时钟同步方法（clocking methodology）规定了信号可以读出和写入的时间。规定信号的读写时间非常重要，因为如果在读信号的同时写信号，那么读到的值可能是该信号的旧值，也可能是新写入的值，甚至可能是二者的混合。计算机设计无法容忍这种不可预测性。时钟同步方法就是为避免这种情况而提出的。

为简单起见，假定我们采用边沿触发的时钟(edge-triggered clocking)，即存储在时序逻辑单元中的所有值仅在时钟边沿更新，这是从低电平快速跳变到高电平（反之亦然）的过程。因为只有状态单元能存储数据值，所有组合逻辑单元都必须从状态单元集合接收输入，并将输出写入状态单元集合。其输入是之前某时钟周期写入的值，输出的值可以在后续时钟周期使用。

==== 数据通路

数据通路是计算机处理器中一个核心的硬件部分，专门用于传输、存储和处理指令和数据。它由寄存器、算术逻辑单元（ALU）、多路选择器（MUX）、数据总线、存储器等模块组成，负责在指令执行过程中完成数据的流动和运算操作。数据通路通过硬件资源的协同工作，将指令的每个步骤具体化，从而实现处理器功能。

数据通路的作用是完成指令执行的全部过程，包括指令的取指、译码、执行、存储访问和写回操作。通过程序计数器（PC），数据通路能够确定当前指令的位置并从指令存储器中读取；通过寄存器文件和 ALU，数据通路可以完成算术和逻辑运算；通过多路选择器和数据总线，数据通路能在不同的硬件模块之间高效地传递数据；通过数据存储器，数据通路支持加载和存储操作。它的设计决定了处理器的性能、效率和指令支持能力，是实现计算任务的硬件基础。

==== 单周期处理器的实现

TIP: 待定

==== 为什么现在不使用单周期实现

尽管单周期设计可以正确工作，但是在现代设计中不采取这种方式，因为它的效率太低。究其原因，是在单周期设计中时钟周期对于每条指令必须等长。这样，处理器中的最长路径决定了时钟周期。这条路径很可能是一条load指令，它连续地使用5个功能单元：指令存储器、寄存器堆、ALU、数据存储器和寄存器堆。虽然CP1为1（见第1章），但由于时钟周期太长，单周期实现的整体性能可能很差。使用单周期设计的代价是显著的，但对于这个小指令集而言，或许是可以接受的。历史上，早期具有简单指令集的计算机确实采用这种实现方式。但是，如果要实现浮点单元或更复杂的指令集，单周期设计根本无法正常工作。由于时钟周期必须满足所有指令中最坏的情况，所以不能使用那些缩短常用指令执行时间而不改变最坏情况的实现技术。因此，单周期实现违反了第1章中加速经常性事件这一设计原则。在4.6节，我们将看到一种称为流水线的实现技术，它使用与单周期相似的数据通路，但吞吐量更高，效率更高。流水线技术通过同时执行多条指令来提高效率。

=== 多周期实现

在多周期实现中，执行中的每一步都需要1个时钟周期。多周期实现允许每个指令多次使用同一个功能单元，只要它在不同的时钟周期内使用。这种共享有助于减少所需的硬件数量。允许指令采用不同数量的时钟周期，以及在单条指令的执行中共享功能单元是多周期设计的主要优势。虽然多周期实现可以降低硬件成本，但今天几乎所有的芯片都使用流水线来提高性能。

多周期处理器是一种通过将指令执行过程划分为多个阶段、在多个时钟周期内完成的处理器设计。相比单周期处理器，多周期处理器可以在不需要重复硬件资源的情况下完成指令执行，从而实现更高的硬件利用率和更灵活的设计。其主要组成模块包括控制单元、程序计数器（PC）、指令存储器、寄存器文件、算术逻辑单元（ALU）、数据存储器和多路选择器等。

多周期处理器的工作流程通过阶段化的方式逐步完成每条指令的执行。首先，程序计数器提供当前指令的地址，指令存储器根据地址取出指令并送入控制单元。控制单元解析指令，生成对应的控制信号，引导寄存器文件从指定寄存器中读取操作数，同时为后续阶段设定路径。接下来，ALU 执行算术或逻辑运算，或者用于计算存储器的访问地址。对于加载或存储指令，ALU 的输出作为地址输入到数据存储器，数据存储器根据指令类型进行读写操作。最后，处理器将运算结果或者从存储器读取的数据写回寄存器文件，完成指令的执行。

在多周期处理器中，每个时钟周期只执行一部分工作，例如取指、译码、执行、存储访问或写回。这种设计允许同一硬件资源（如 ALU 或数据存储器）在不同阶段为不同指令使用，因此相较于单周期处理器，硬件资源需求更低。此外，多周期处理器的控制单元采用有限状态机（FSM）设计，根据当前指令的类型和执行阶段生成精确的控制信号，确保每个模块在正确的时间参与操作。

多周期处理器通过分阶段执行，平衡了性能与硬件资源之间的关系，使其适合于资源有限的系统设计，同时可以支持复杂指令集。然而，由于指令完成时间不固定，其性能通常低于流水线处理器，但更容易实现且硬件开销较低。

=== 流水线概述

流水线是一种能使多条指令重叠执行的实现技术。使用流水线来使指令能重叠执行，以提高性能。即指令级并行（ILP）。目前，流水线技术广泛应用。

下面使用一个比喻概述流水线的概念及相关问题。

任何做洗衣工作的人都不自觉地使用流水线技术。非流水线的洗衣过程包含如下步骤：

1. 将一批脏衣服放入洗衣机。

2. 洗衣机洗完后，将湿衣服取出并放入烘干机

3. 烘干机完成后，将干衣服取出，放在桌上并叠起来

4. 叠好后，请你的室友帮忙把衣服收好。

当这一批衣服收好后，再开始洗下一批脏衣服。

流水线方法花费的时间少得多。当第一批衣服从洗衣机中取出并放人烘干机后，就可以把第二批脏衣服放入洗衣机。当第一批衣服烘干完成后，就可以把它们放在桌上叠起来，同时把洗衣机中洗好的衣服放入烘干机，再将下一批脏衣服放入洗衣机。接着让你的室友把第一批衣服从桌上收好，你开始叠第二批衣服，烘干机开始烘干第三批衣服，同时可以把第四批衣服放人洗衣机。此时，所有的洗衣步骤（称为流水线阶段）在同时工作。只要每个阶段使用不同的资源，我们就可以用流水线的方法完成任务。

流水线的矛盾在于，对于一双脏袜子，从把它放人洗衣机到被烘干、叠好和收起的时间在流水线中并没有缩短；然而对于许多负载来说，流水线更快的原因是所有工作都在并行地执行。所以单位时间能够完成更多工作，流水线提高了洗衣系统的吞吐率（throughput)。因此，流水线不会缩短洗一次衣服的时间，但是当有很多衣物需要洗时，吞吐率的提高减少了完成整个任务的时间。

如果每个步骤需要的时间相同，并且要完成的工作足够多，那么由流水线产生的加速比等于流水线中步骤的数目，在这个例子中是4倍：洗涤、烘干、折叠和收起。因此，流水线方式洗衣是非流水线方式洗衣速度的4倍：流水线中20次洗衣需要的时间是一次洗衣的5倍，而20次非流水线洗衣的时间是一次洗衣的20倍。

同样的原则也可用于处理器，即采用流水线方式执行指令。RISC-V指令执行通常包含五个步骤：

1. 从存储器中取出指令。

2. 读寄存器并译码指令。

3. 执行操作或计算地址。

4. 访问数据存储器中的操作数（如有必要）。

5. 将结果写人寄存器（如有必要）。

因此，本章探讨的RISC-V流水线有五个阶段，正如流水线加速洗衣过程一样。

==== 面向流水线的指令系统设计

尽管上面的例子只是对流水线的简单介绍，但我们也能够通过它了解面向流水线设计的RISC-V指令系统。

第一，所有RISC-V指令长度相同。这个限制简化了流水线第一阶段取指令和第二阶段指令译码。在像x86这样的指令系统中，指令长度从1字节到15字节不等，流水线设计更具挑战性。现代x86架构在实现时，将x86指令转换为类似RISC-V指令的简单操作，然后流水化这些简单操作，而不是流水化原始的x86指令。

第二，RISC-V只有几种指令格式，源寄存器和目标寄存器字段的位置相同。

第三，存储器操作数只出现在RISC-V的load或store指令中。这个限制意味着可以利用执行阶段来计算存储器地址，然后在下一阶段访问存储器。如果可以操作内存中的操作数，就像在x86中一样，那么第三阶段和第四阶段将扩展为地址计算阶段、存储器访问阶段和执行阶段。

==== 流水线数据通路和控制

TIP: p205

==== 利用指令级并行的基本编译器技术

- 找出除维护循环的代码外互不相关的循环迭代，判定循环展开是有用的。

- 使用不同寄存器，以避免由于不同运算使用相同寄存器而造成的非必要约束（比如，名称依赖）。

- 去除多余的测试和分支指令，并调整循环终止与迭代代码。

- 通过观察不同迭代中的载人指令与存储指令互不相关，判定展开后的循环中的载人指令和存储指令可以交换位置。这一变换需要分析存储器地址，确认它们没有引用同一地址。

- 在保留必要的依赖，以得到与原代码相同的结果的前提下，对代码进行调度。

要进行所有这些变换，关键是要理解指令之间的依赖关系，而且要知道在这些关系下如何改变指令或调整指令的顺序。

有3种效果会限制循环展开带来的好处：

1. 每次展开操作分摊的开销降低；

2. 代码规模限制;

3. 编译器限制。

我们首先考虑循环开销问题。将循环展开4次时，它在指令之间产生了足够的并行性，可以在没有停顿周期的情况下调度循环。事实上，在14个时钟周期中，只有2个周期是循环开销：维护索引值的addt和终止循环的bne。如果将循环展开8次，这一开销将从每个元素1/2周期降低到1/4周期。

展开的第二个限制是代码规模的增长。对于较大规模的循环，代码规模的增长可能是一个问题，特别是当它会导致指令缓存缺失率上升时。

还有一个通常比代码规模更重要的因素，就是由于大量进行展开和调度而造成寄存器数量不足。由于在大段代码中进行指令调度而产生的这一副作用被称为寄存器紧缺（register pressure）。之所以会出现这种情况，是因为调度代码以增加IP时导致存活值的数量增加。在大量进行指令调度之后，可能无法将所有存活值都分配到寄存器中。尽管转换后的代码在理论上运行速度更快，但由于它会造成寄存器紧缺，所以可能会损失部分乃至全部收益。在没有展开循环时，分支就足以限制大量使用调度，所以寄存器紧缺几乎不会成为问题。但是，循环展开与大量调度结合起来却可能导致这一问题。在需要暴露更多独立指令序列的多发射处理器中，这个问题变得尤其具有挑战性，因为这些指令序列的执行可能是重叠的。一般来说，高级、复杂转换的应用导致现代编译器的复杂度大幅增加，而在生成具体代码之前，很难度量这种应用带来的可能提升。

循环展开是一种简单但有用的方法，能够增大可以有效调度的直线代码片段的规模。这种转换在各种处理器上都非常有用，从前面研究过的简单流水线，到多发射超标量，再到本章后面要研究的VLIW。

=== 冒险与竞争

|====
|结构冒险|缺乏硬件支持导致，可以在设计流水线时避免
|数据冒险|一个指令必须等待其他指令的结果才能完成导致的停顿为数据冒险，采用前递或旁路、动态调度技术优化
|控制冒险|在分支判断结果未出现时，无法得知下一条指令是什么，导致停顿。采用分支预测技术优化
|====

TIP: 流水线中有一种情况，在下一个时钟周期中下一条指令无法执行。这种情况被称为冒险（hazard).我们将介绍三种冒险。结构冒险第一种冒险叫作结构冒险(structural hazard)。即硬件不支持多条指令在同一时钟周期执行。在洗衣例子中，如果用洗衣烘干一体机而不是分开的洗衣机和烘干机，或者如果你的室友正在做其他事情而不能收好衣服，都会发生结构冒险。这时，我们精心设计的流水线就会受到破坏。如上所述，RISC-V指令系统是面向流水线设计的，这使得设计人员在设计流水线时很容易避免结构冒险。然而，假设图4-29的流水线结构只有一个而不是两个存储器，那么如果有第四条指令，则会发生第一条指令从存储器取数据的同时第四条指令从同一存储器取指令，流水线会发生结构冒险。数据冒险由于一个步骤必须等待另一个步骤完成而导致的流水线停顿叫作数据冒险(data hazard)。假设你在叠衣服时发现一只袜子找不到与之匹配的另一只。一种可能的策略是跑到房间，在衣橱中找，看是否能找到另一只。显然，当你在找袜子时，完成烘干准备被折叠的衣服和那些已经洗完准备去烘干的衣服，不得不停顿等待。在计算机流水线中，数据冒险源于一条指令依赖于前面一条尚在流水线中的指令(这种关系在洗衣例子中并不存在)。例如，假设有一条加法指令，它后面紧跟着一条使用加法的和的减法指令(x19)：add x19.x0,x1sub x2,×19.×3在不做任何干预的情况下，这一数据冒险会严重地阻碍流水线。add指令直到第五个阶段才写结果，这将浪费三个时钟周期。尽管可以尝试通过编译器来消除这些冒险，但结果并不令人满意。这些依赖经常发生，并且导致的延迟太长，所以不可能指望编译器将我们从这个困境中解救出来一种基本的解决方案是基于以下发现：不需要等待指令完成就可以尝试解决数据冒险。对于上面的代码序列，一旦ALU计算出加法的和，就可将其作为减法的输入。向内部资源添加额外的硬件以尽快找到缺少的运算项的方法，称为前递（forwarding）或旁路(bypassing)


=== 例外

==== RISC-V体系结构中如何处理例外

==== 流水线实现中的例外

=== 指令间的并行性

编译器或处理器来猜测指令的行为并提前开始执行。如果猜测正确则进行指令提交，错误则清除结果并从执行正确的指令。

- 推测的概念

- 基于硬件的推测

- 以多发射和静态调度来利用指令级并行

- 以动态调度、多发射和推测来利用指令级并行

- 用于指令交付和推测的高级技术
