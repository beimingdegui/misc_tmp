== 计算机的算术运算

=== 加法和减法

加法是数字从右到左逐位相加，并将进位传送到左侧的下一位数字，与手动计算一样。减法也使用加法实现：相应操作数被简单取反后再进行加法操作。

==== 加法与减法的溢出判断

由于硬件规模总是有一定限制的，比如字宽为32位，当运算结果超过这个限制时，就会发生溢出。在加法中何时会发生溢出？当不同符号的操作数相加时，不会发生溢出。因为总和一定不会大于其中任意一个操作数。例如，stem:[-10+4=-6]。由于操作数可以表示成32位且其总和不大于任一操作数，所以总和也一定能表示成32位。因此，当正负操作数相加时不会发生溢出。在减法中也有类似的不会发生溢出的情况，但原理相反：当操作数的符号相同时，不会发生溢出。为了说明这一点，需要记住stem:[c-a=c+(-a)]，这是因为我们通过将第二个操作数取反然后相加来实现减法。因此，当相同符号的操作数相减时，最终会变成相反符号的操作数相加。从上一段落可知，在这种情况下不会发生溢出。知道加法和减法运算在什么时候不会发生溢出固然很好，但如何检测它何时发生呢？显然，加或减两个32位的数字可能产生一个需要33位才能表示的结果。缺少第33位意味着当溢出发生时，符号位被结果的值占用而非结果的正确符号。由于溢出结果只可能多一位，所以只有符号位可能是错误的。因此，当两个正数相加但和为负数时，说明发生了溢出，反之亦然。这个假的和值意味着产生了向符号位的进位。

当出现了不合理的运算结果时，意味着发生了溢出。下表展示了溢出发生时的运算、操作数和运算结果。

[options="header"]
|====
|操作 | 操作数A | 操作数B | 表明溢出的结果

|stem:[A+B]
|stem:[\ge 0]
|stem:[\ge 0]
|stem:[< 0]

|stem:[A+B]
|stem:[< 0]
|stem:[< 0]
|stem:[\ge 0]

|stem:[A-B]
|stem:[\ge 0]
|stem:[< 0]
|stem:[< 0]

|stem:[A-B]
|stem:[< 0]
|stem:[\ge 0]
|stem:[\ge 0]

|====

无符号整数通常用于表示忽略溢出的内存地址。计算机的有限字长意味着算术运算可能会产生过量而无法用这种固定字长表示的运算结果，即发生溢出。虽然无符号数的溢出容易检测，但无符号数通常使用自然数做地址运算，而程序通常不需要检测地址计算的溢出，所以这些溢出总被忽略。

=== 乘法

==== 串行版的乘法运算及其硬件实现

TIP: P134三张图

该设计模仿了我们在小学学到的算法，上图展示了该设计的硬件结构。假设乘数位于32位乘法器寄存器中，并且将64位乘积寄存器初始化为0。我们需要在每一步计算中将被乘数左移一位，因为它可能会和之前的中间结果相加。在32步计算之后，32位被乘数会向左移动32位。因此，我们需要一个64位的被乘数寄存器，将其初始化为右半部分的32位被乘数和左半部分的零。然后该寄存器每执行一步便左移1位，将被乘数与64位的乘积寄存器中的中间结果对齐并累加到中间结果。

TIP: 1

下图显示了对于操作数的每一位都需要做的三个基本步骤。第一步中的乘数最低位（乘数第0位）决定了是否要把被乘数加到积寄存器当中。第二步中的左移起着将中间操作数左移的作用，就像手工计算做乘法一样。第三步中的右移给出了下次迭代要检测的乘数的下一位。这三个步骤重复32次就会得到最后的积。如果每个步骤花费一个时钟周期，那么该算法计算两个32位数相乘差不多要花费200个时钟周期。像乘法这样的算术运算的重要性随程序的不同而变化，但一般加法和减法出现的次数会是乘法的5到100倍。因此，在许多应用中，乘法花费若干时钟周期并不会显著影响性能。但是，Amdahl定律提醒我们，一个慢速操作如果占据了一定的比例，也会限制程序性能。
TIP: 2
这种算法和硬件很容易改进到每步只花费一个时钟周期。加速来源于操作的并行执行：如果乘数位是1.那么对被乘数和乘数进行移位，与此同时，把被乘数加到积上。硬件只需要保证它检测的是乘数的最右位，而且得到的是被乘数移位前的值。注意到寄存器和加法器有未使用的部分后，通常会将加法器和寄存器的位长减半以进一步优化硬件结构。下图展示了修正后的硬件。

TIP: 3

==== 带符号乘法

对于如何处理带符号乘法，最简单的方式是先把被乘数和乘数转换为正数，然后记住它们的初始符号。这样，将之前的算法迭代执行31次，符号位不参与计算。正如我们小学学到的那样，只有在乘数和被乘数符号相反时，对积取反。事实证明，如果记住我们正在处理具有无限位长的数，并且只用32位来表示它们，则上面的最后一种算法适用于带符号数。因此，在移位时需要对带符号数的积进行符号扩展。当算法结束时，低位的双字就是32位积。

==== 快速乘法

摩尔定律提供了非常充足的资源，从而使硬件设计人员可以实现更快的乘法硬件。通过在乘法运算开始的时候检查32个乘数位，就可以判定是否要将被乘数加上。快速乘法可以通过为每个乘数位提供一个32位加法器来实现：一个输入是被乘数和一个乘数位相与的结果，另一个输入是上一个加法器的输出。一种简单的方法是将右侧加法器的输出端连接到左侧加法器的输入端，形成一个高64位的加法器栈。另一种方式是将这32个加法器组织成如下图所示的并行树。这样我们就只需要等待stem:[log_2(32)]，即5次32位长加法的时间，而不是32次。

TIP: p136

由于使用进位保留加法器，乘法的速度甚至比5次加法还要快，并且因为容易将上述设计流水化，它能够同时支持多个乘法。

==== RISC-V中的乘法

为了产生正确带符号或无符号的64位积，RISC-V有四条指令：乘（mul），乘法取高位（mulh)，无符号乘法取高位（mulhu)，有符号/无符号乘法取高位（mulhsu）。要获得整数32位积，应使用mu1指令。要想得到64位积的高32位，如果两个操作数都是有符号的，应使用mulh指令；如果两个操作数都是无符号的，则使用mulhu指令；如果一个操作数是有符号的而另一个是无符号的，则使用mulhsu指令。

=== 除法

==== 除法运算及其硬件实现

下图展示了模拟基本除法算法的硬件。在开始时将32位的商寄存器置0.算法的每次迭代都需要将除数右移一位，因此开始需要将除数放置到64位的除数寄存器的左半部分，并且每运算一步并将其右移1位，使之与被除数对齐。余数寄存器初始化为被除数。

TIP: p138 1

下图展示了第一个除法算法的三个步骤。与人不同，计算机没有聪明到能预先知道除数是否小于被除数。它必须先在步骤1中用被除数减去除数，这正是我们实现比较所使用的方式。如果结果是正数或0，则除数小于或等于被除数，所以在商中生成一位1(步骤2a)。如果结果为负，则下一步是通过将除数加回余数来恢复原始值，并在商中生成一位0（步骤2b）。除数右移，然后再次迭代。在迭代完成后，余数和商将存放在其同名的寄存器中。

TIP: p138 2

这个算法及其硬件结构可以被改进得更快且更便宜。通过操作数移位和商与减法同时进行来加速。该细化包括注意哪里有未使用的寄存器和将加法器和寄存器宽度减半。图3-11展示了修改后的硬件。

TIP: p139 1

==== 有符号除法

计算机中的有符号除法是一种处理带符号整数的除法运算方法，能够正确处理正数和负数之间的除法关系。其核心思想是对符号和数值分别处理，以确保结果的符号正确，并在运算过程中避免符号干扰。以下是处理有符号除法的主要步骤。

首先，确定被除数和除数的符号。通过检查两数的符号位（通常是最高有效位），判断它们是否为正数或负数。如果符号相同（两者均为正或均为负），最终的商为正；如果符号不同（一个为正，一个为负），最终的商为负。这一步确定了商的符号，同时便于后续操作只处理数值部分。

接着，将被除数和除数的数值部分转换为绝对值进行处理。通过忽略符号位，可以将负数转化为正数，从而将后续的计算简化为无符号除法。随后，计算绝对值的商和余数，这通常是通过硬件或软件实现的无符号整数除法算法完成的。

在计算得到商和余数后，需要恢复结果的符号。商的符号按照第一步的判断进行设置，即根据被除数和除数符号是否相同来决定正负号。余数的符号通常与被除数相同，以保持数学意义上的一致性。

最后，将符号恢复后的商和余数作为最终结果返回。这个过程确保了除法运算能够正确处理正负数之间的关系，同时保持了计算机中带符号整数的标准表示方式。

==== 快速除法

摩尔定律适用于除法硬件以及乘法运算，所以希望能够通过其硬件来加速除法。通过使用许多加法器来加速乘法，但不能对除法使用相同的方法。因为在执行下一步运算之前，需要先知道减法结果的符号，而乘法运算可以立即计算32个部分积。有些技术每步可以产生多于一位的商。SRT除法技术试图根据被除数和余数的高位来查找表，以预测每步的多个商的位数。它依靠后续步骤纠正错误预测。今天的典型值是4位。关键在于猜测要减去的值。对于二进制除法，只有一个选择。这些算法使用余数的6位和除数的4位来索引查找表，以确定每个步骤的猜测。

这种快速方法的准确性取决于查找表中的值是否合适。3.9节中的谬误展示了如果表不正确将会发生什么情况。

==== RISC-V中的除法

上文中提到的乘法与除法都可以使用相同的顺序执行硬件。唯一需要的是一个可以左右移位的64位寄存器和一个实现加法或减法的32位ALU。

为了处理有符号整数和无符号整数，RISC-V有两条除法指令和两条余数指令：除（div），无符号除(divu)，余数（rem），无符号余数（remu）。

=== 浮点运算

浮点数的表示基于科学计数法的思想，将数值拆分为三个部分：符号、尾数和指数，从而能够在有限的存储空间内表示非常大的数值范围和较高的精度。浮点数的运算原理涵盖其表示方式、对齐、计算和规范化等多个步骤。

浮点数通常采用IEEE 754标准表示。一个浮点数由符号位、指数部分和尾数部分组成。符号位决定数值是正还是负；指数部分采用偏移表示法（通常为偏移值加上实际指数），用来表示浮点数的数量级；尾数部分存储有效数字，并隐含一个固定的基数（如2或10），构成完整的数值表示。

在浮点运算中，首先需要对操作数进行对齐。对齐是指通过调整指数，使得两数的指数部分相同，从而保证尾数能够直接参与加法或减法运算。对齐时，较小指数的数值会通过右移尾数来提升指数，可能会丢失部分精度。接下来，计算器会执行尾数的加法、减法、乘法或除法操作，具体过程与整数运算类似，但需要对结果进行额外的处理以符合浮点数的格式。

运算完成后，结果可能需要进行规范化和舍入。规范化是指调整尾数和指数，使尾数的最高位为非零，以便最大限度利用存储精度。如果尾数超出浮点数的表示范围，则需要通过调整指数来缩放结果。舍入是为了处理由于尾数截断而导致的误差，常用的舍入方式包括向上取整、向下取整或最近值舍入。

浮点运算还需要处理特殊情况，如零、无穷大和非数字（NaN）。这些特殊值由IEEE 754标准定义，用于应对计算中的异常情况。浮点数运算的复杂性主要来自于其需要在保持数值范围和精度之间取得平衡，因此需要硬件和算法的高效支持。浮点运算广泛应用于科学计算、图形处理和工程模拟中，是计算机实现高精度数值计算的重要基础。

==== 浮点表示

浮点表示的设计者必须在尾数的位数大小和指数的位数大小之问找到一个平衡，因为固定的字大小意味着若一部分增加一位，则另一部分就得减少一位。即要做精度和范围之间的权衡：增加尾数位数的大小可以提高小数精度，而增加指数位数的大小则可以增加数的表示范围。

浮点数通常占用多个字的长度。下图是RISC-V浮点数的表示方法，其中S是浮点数的符号（l表示负数），指数由8位指数字段（包括指数的符号）表示，尾数由23位数表示。正如第2章提过的那样，这种表示称为符号和数值，符号与数值的位是相互分离的。

TIP: p143图

通常来讲，浮点数可以这样表示：

[stem]
++++
(-1)^S \times F × 2^E
++++

F是尾数字段中表示的值，而E是指数字段表示的值。

这些指定的指数和尾数位长使RISC-V计算机具有很大的运算范围。小到stem:[2.0_{10} \times 10^{-38}]，大到stem:[2.0_{10} \times 10^{38}]，计算机都能表示出来。但是它和无穷大不同，所以仍然可能存在数太大而表示不出来的情况。因此，和整点运算一样，浮点运算中也会发生溢出例外。注意这里的溢出表示因指数太大而无法在指数字段中表示出来。

浮点运算还会导致出现一种新的例外情况。正如程序员想知道他们什么时候计算了一个难以表示的太大的数一样，他们还想知道他们正在计算的非零小数是否变得小到无法表示，这两个事件都可能导致程序给出不正确的答案。为了和上溢区分开来，我们把这种情况称为下溢。当负指数太大而指数字段无法表示时，就会出现这种情况。

减少下溢或上溢发生概率的一种方法是提供另一种具有更大指数范围的格式。在C语言中，这个数据类型称为双精度（double）.基于双精度的运算称为双精度浮点运算，而单精度浮点就是前面介绍的格式。

双精度浮点数需要一个RISC-V双字才能表示，如下所示，其中S仍然是数的符号位。指数字段为11位，尾数字段为52位。

TIP: p144

RISC-V双精度可以表示的实数范围小到stem:[2.0_{10} \times 10^{-308}]，大到stem:[2.0_{10} \times 10^{308}]。尽管双精度确实增加了指数字段能表示的范围，但其最主要的优点是由于有更大的尾数位数而具有更高的精度。

==== 例外和中断

在上溢或下溢时应该让计算机发生什么以让用户知道出现了问题?有些计算机会通过引发例外（有时也称作中断）来告知问题的出现。例外或中断在本质上是一种非预期的过程调用。造成溢出的指令的地址保存在寄存器中，并且计算机会跳转到预定义的地址以调用相应的例外处理程序。中断的地址被保存下来，以便在某些情况下可以在执行纠正代码之后继续执行原程序。RISC-V计算机不会在上溢或下溢时引发例外，不过，软件可以读取浮点控制和状态寄存器(fcsr)来检测是否发生上溢或下溢。

==== IEEE754浮点数标准

IEEE 754 是一种广泛应用于计算机系统的浮点数标准，旨在规范浮点数的表示、运算、舍入和异常处理，使不同计算平台能够一致地处理实数运算。最初的标准于 1985 年发布，后续版本不断改进，支持更广泛的计算需求。以下是该标准的主要内容和特点：

- 浮点数的表示

IEEE 754 采用类似于科学计数法的形式表示浮点数，通过二进制分解为三个部分：符号位（Sign）、指数部分（Exponent）和尾数部分（Mantissa，又称有效位）。浮点数表示的通用公式为：
[stem]
++++
N = (-1)^S \times F × 2^E
++++
其中：

S：符号位，表示数值的正负。0 为正数，1 为负数。

E：指数部分，使用偏移表示法存储。实际指数通过 E_actual = E_stored - bias 计算，bias 是一个偏移值。

M：尾数部分，表示有效数字的二进制小数。标准规定隐含一个整数部分，通常为1。
 
- 特殊值的表示
IEEE 754 设计了特殊值来表示异常或边界情况：

1. 零：符号位可以是0或1，指数部分全为0，尾数全为0。
2. 无穷大（Infinity）：符号位表示正负，指数部分全为1，尾数全为0。
3. 非数字（NaN，Not a Number）：用于表示未定义或无效的结果，如 0/0。指数部分全为1，尾数非零。
4. 非规格化数（Denormalized Number）：当指数部分为0且尾数非零时，表示非常接近零的小数。

- 舍入模式
IEEE 754 提供了多种舍入模式，用于解决尾数截断引发的误差：

向最近值舍入（默认）
向零舍入
向正无穷大舍入
向负无穷大舍入

TIP: 补充or删除

==== 浮点加法
==== 浮点乘法
==== RISC-V中的浮点指令
==== 精确算术

=== 并行性与计算机算术

通过划分进位链，可以同时对多个短向量进行并行操作。即数据级并行

由于手机、平板电脑或笔记本电脑中的每个微处理器都有自己的图形显示器，随着晶体管数量的增加，对于图形操作的支持也不可避免地会增加。

许多图形系统最初使用8位数据来表示三原色中的一种，外加8位来表示一个像素的位置。在电话会议和视频游戏中添加了扬声器和麦克风对声音进行支持。音频采样需要8位以上的精度，但16位精度就已经足够了。

所有微处理器都对字节和半字有特殊支持，使其在存储时占用更少的存储器空间，但在典型的整数程序中对这类大小数据的算术运算非常少，因此几乎不支持除数据传输之外的其他操作。架构师发现，许多图形和音频应用会对这类数据的向量执行相同操作。通过在128位加法器内划分进位链，处理器可以同时对16个8位操作数、8个16位操作数、4个32位操作数或2个64位操作数的短向量进行并行操作。

这种分割加法器的开销很小，但带来的加速可能很大。

将这种在一个宽字内部进行的并行操作称为子字并行(subword parallelism)。更通用的名称是数据级并行(data level parallelism)。对于单指令多数据，它们也被称为向量或SIMD。多媒体应用程序的逐渐普及促使了支持易于并行计算的窄位宽操作的算术指令的出现。
